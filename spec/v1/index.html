<!doctype html><title>Chitin format specification v1 DRAFT</title><meta name=go-import content="chitin.io/chitin git https://github.com/chitin-io/chitin"><style>body{background-color:#ffffea;display:flex;justify-content:center}body>div{flex:1}nav.sidebar>ul{display:block;padding:0;margin:0;margin-top:40px;background-color:#f9cc9d}nav.sidebar>ul>li{display:block;padding:0;margin:0}nav.sidebar>ul>li>a{display:block;text-decoration:none;overflow-x:hidden;border-top:1px solid #000;padding:.2em}nav.sidebar>ul>li>a>p{font-size:80%;margin:.2em}nav.sidebar>ul>li:first-child>a{border-top:0}nav.sidebar>ul>li>a:hover{background-color:#fddd9b}table{border-spacing:0}table td,table th{padding:.2em}table th{border-bottom:1px solid #aaa;border-spacing:0}table td:not(:first-child),table th:not(:first-child){border-left:1px solid #aaa;border-spacing:0}body{counter-reset:h1}h1{counter-reset:h2}h2{counter-reset:h3}h3{counter-reset:h4}h4{counter-reset:h5}h5{counter-reset:h6}h1:not(:first-of-type):before{counter-increment:h1;content:counter(h1) ". "}h2:before{counter-increment:h2;content:counter(h1) "." counter(h2) ". "}h3:before{counter-increment:h3;content:counter(h1) "." counter(h2) "." counter(h3) ". "}h4:before{counter-increment:h4;content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) ". "}h5:before{counter-increment:h5;content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) ". "}h6:before{counter-increment:h6;content:counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) "." counter(h5) "." counter(h6) ". "}#content nav ul{counter-reset:toc;list-style-type:none}#content nav li::before{counter-increment:toc;content:counters(toc,".") ". "}</style><div id=content style=flex-shrink:0;flex-basis:80%;max-width:30em;margin:1em><div style=position:relative><div style=color:#d0d0d0;opacity:.3;font-family:helvetica,sans-serif;font-size:300px;font-weight:700;position:absolute;top:500px;left:-250px;-webkit-transform:rotate(-45deg);z-index:-1>DRAFT</div></div><h1 id=chitin-format-specification-v1-draft>Chitin format specification v1 DRAFT</h1><nav><ul><li><a href=#definitions>Definitions</a><ul><li><a href=#varuint><code>varuint</code></a><li><a href=#varsint><code>varsint</code></a><li><a href=#varfloat><code>varfloat</code></a></ul><li><a href=#types>Types</a><ul><li><a href=#integers>Fixed-width integers</a><li><a href=#floats>Floating point numbers</a><li><a href=#array-types>Array types</a><li><a href=#alias-types>Aliases</a></ul><li><a href=#length-prefixed-encoding>Length-prefixed encoding</a><ul><li><a href=#alignment>Alignment</a><li><a href=#interleaving-fixed-length-items>Interleaving fixed length items</a><li><a href=#padding-optimization>Padding optimization</a></ul><li><a href=#f-e-m>Frames, Envelopes and Messages</a><li><a href=#frame>Frame</a><li><a href=#envelope>Envelope</a><li><a href=#message-wire-v1>Message wire format v1</a><ul><li><a href=#slot>Slot</a><li><a href=#field>Field</a><ul><li><a href=#fixed-length-fields>Fixed length fields</a><li><a href=#self-delimited-fields>Self-delimited fields</a><li><a href=#length-prefixed-fields>Length-prefixed fields</a><li><a href=#encoding-more-complex-types>Encoding more complex types</a></ul></ul><li><a href=#schema>Schema</a><ul><li><a href=#schema-data-model>Schema Data Model</a><li><a href=#schema-language>Schema Language</a></ul><li><a href=#rationale>Rationale</a><ul><li><a href=#varuint-1>varuint</a><li><a href=#interleaved-field-lengths-and-contents>Interleaved field lengths and contents</a><li><a href=#null-padding-is-not-visible-to-applications>Null padding is not visible to applications</a></ul></ul></nav><p>Chitin is a data serialization format. See <a href=https://chitin.io/>https://chitin.io/</a> for introduction and motivation.<p><strong>DRAFT VERSION</strong><h1 id=definitions>Definitions</h1><h2 id=varuint><code>varuint</code></h2><p>Variable-length unsigned integer encoding. Defined in <a href=http://www.sqlite.org/src4/doc/trunk/www/varint.wiki>SQLite&rsquo;s Variable-Length Integers</a>.<p>This is <strong>not</strong> the <a href=https://developers.google.com/protocol-buffers/docs/encoding#varints>Protocol Buffer varint format</a>.<h2 id=varsint><code>varsint</code></h2><p>Variable-length signed integer encoding. Signed integers are converted to unsigned integers as per <a href=https://developers.google.com/protocol-buffers/docs/encoding#signed-integers>ZigZag encoding</a>, and then encoded as <a href=#varuint><code>varuint</code></a>.<h2 id=varfloat><code>varfloat</code></h2><p>Variable-length float encoding. Floats are converted to integers as per IEEE-754, their bytes are reordered so that exponent is in the least significant bits, and encoded as <code>varuint</code>.<sup class=footnote-ref id=fnref:varfloat><a rel=footnote href=#fn:varfloat>1</a></sup> This minimizes space used by smaller numbers in a way similar to <code>varuint</code>.<h1 id=types>Types</h1><p><strong>TODO convenience support for bit maps, flags</strong><h2 id=integers>Fixed-width integers</h2><ul><li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>: unsigned integers of the given bit width<li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>: signed integers of the given bit width</ul><h2 id=floats>Floating point numbers</h2><ul><li><code>float32</code>: IEEE-754 32-bit floating-point numbers<li><code>float64</code>: IEEE-754 64-bit floating-point numbers</ul><h2 id=array-types>Array types</h2><ul><li><code>[n]T</code>: a fixed-length array of <code>n</code> items of type <code>T</code><li><code>[]T</code>: a variable-length array of items of type <code>T</code></ul><p>Where <code>T</code> is any type that is valid in that context.<h2 id=alias-types>Aliases</h2><ul><li><code>byte</code>: like <code>uint8</code>, but with a semantic hint that it&rsquo;s not used as a number<li><code>string</code>: like <code>[]byte</code>, but with a semantic hint that it contains human-readable text in UTF-8 encoding</ul><h1 id=length-prefixed-encoding>Length-prefixed encoding</h1><p>This section describes an encoding for sequences of variable-length items.<p>In its basic form, the encoding simply alternates <code>varuint</code> lengths with the full content of one item.<p>Length 0 is reserved for use as padding (see <a href=#alignment>Alignment</a>). Encoded length is content length + 1.<blockquote><p><em>Example</em>: an encoding of two variable-length messages with contents <code>x</code> and <code>foo</code>:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<tbody><tr><td>value<td>2<td>&ldquo;x&rdquo;<td>4<td>&ldquo;f&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;o&rdquo;</table><p><em>Example</em>: an encoding of a variable-length message with a content of the letter <code>x</code> repeated 1000 times:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>…<th>1001<tbody><tr><td>value<td>243<td>249<td>&ldquo;x&rdquo;<td>&ldquo;x&rdquo;<td>…<td>&ldquo;x&rdquo;</table></blockquote><h2 id=alignment>Alignment</h2><p>The content may have alignment requirements. This allows for efficient processing of the data, e.g. avoiding alignment faults and enabling special instructions to be used.<p>When decoding a buffer, alignment can only be guaranteed if the buffer is aligned according to the largest alignment guarantee that can be contained in the buffer. When decoding a stream, the byte position where reading starts is interpreted as offset 0; if part of the stream has already been consumed, this may not match with any file offsets.<p>Libraries allocating buffers MUST either align buffers appropriately, or state they do not support alignment.<p>In the simple case, alignment is implemented by one or more null bytes (value <code>0</code>) after the length.<p>When decoding, the 0 lengths are skipped.<blockquote><p><em>Note</em>: this only works because the decoder also knows the alignment requirements. Otherwise, the padding bytes would be confused for content.<p><em>Example</em>: an encoding of a variable-length message with contents <code>foo</code>, where the content is aligned to a 4-byte boundary:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>6<tbody><tr><td>value<td>4<td>0<td>0<td>0<td>&ldquo;f&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;o&rdquo;</table></blockquote><p>The number of padding bytes depends on the encoded byte count of the <code>varuint</code> length.<blockquote><p><em>Example</em>: an encoding of a variable-length message with a content of the letter <code>x</code> repeated 1000 times, where the content is aligned to a 4-byte boundary:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>…<th>1003<tbody><tr><td>value<td>243<td>249<td>0<td>0<td>&ldquo;x&rdquo;<td>&ldquo;x&rdquo;<td>…<td>&ldquo;x&rdquo;</table><p><em>Example</em>: an encoding of two variable-length messages with contents <code>x</code> and <code>foo</code>, where <code>foo</code> is aligned to a 4-byte boundary:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>6<tbody><tr><td>value<td>2<td>&ldquo;x&rdquo;<td>4<td>0<td>&ldquo;f&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;o&rdquo;</table></blockquote><p>With nested data structures, alignment may be required for a byte that is not the first byte of content.<blockquote><p><em>Example</em>: an encoding of a variable-length message with contents <code>xAbc</code>, where the byte <code>A</code> is aligned to a 4-byte boundary:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>6<tbody><tr><td>value<td>5<td>0<td>0<td>&ldquo;x&rdquo;<td>&ldquo;A&rdquo;<td>&ldquo;b&rdquo;<td>&ldquo;c&rdquo;</table></blockquote><h2 id=interleaving-fixed-length-items>Interleaving fixed length items</h2><p>Fixed length items may be interleaved with length-prefixed items. This is only possible when the decoder will know to expect this.<blockquote><p><em>Example</em>: an encoding of a variable-length message <code>foo</code>, fixed-length message <code>x</code>, and a variable-length message <code>quux</code>:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<tbody><tr><td>value<td>4<td>&ldquo;f&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;x&rdquo;<td>5<td>&ldquo;q&rdquo;<td>&ldquo;u&rdquo;<td>&ldquo;u&rdquo;<td>&ldquo;x&rdquo;</table></blockquote><p>Alignment of fixed length items works as above, by inserting 0 lengths as needed.<blockquote><p><em>Example</em>: an encoding of a variable-length message <code>foobar</code>, fixed-length message <code>x</code> aligned at a 4-byte boundary, and a variable-length message <code>quux</code>:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>10<th>11<th>12<th>13<tbody><tr><td>value<td>7<td>&ldquo;f&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;b&rdquo;<td>&ldquo;a&rdquo;<td>&ldquo;r&rdquo;<td>0<td>&ldquo;x&rdquo;<td>5<td>&ldquo;q&rdquo;<td>&ldquo;u&rdquo;<td>&ldquo;u&rdquo;<td>&ldquo;x&rdquo;</table></blockquote><h2 id=padding-optimization>Padding optimization</h2><p>To minimize the overhead from padding, we can use the padding bytes to encode upcoming item lengths.<p>Instead of padding with null bytes, encoder MAY use bytes from the lengths of the items sequentially after the current item. Decoders MUST support this.<blockquote><p><em>Example</em>: an encoding of three variable-length messages with contents <code>x</code>, <code>foo</code> and <code>y</code>, where <code>foo</code> is aligned to a 4-byte boundary:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<tbody><tr><td>value<td>2<td>&ldquo;x&rdquo;<td>4<td>2<td>&ldquo;f&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;y&rdquo;</table></blockquote><p>The bytes of a <code>varuint</code>-encoded length MAY be split on two sides of an items content.<blockquote><p><em>Example</em>: an encoding of three variable-length messages with contents <code>x</code>, <code>foo</code> and the letter <code>y</code> repeated 1000 times, where <code>foo</code> is aligned to a 4-byte boundary:<table><thead><tr><th>offset<th>0<th>1<th>2<th>3<th>4<th>5<th>6<th>7<th>8<th>9<th>…<th>1007<tbody><tr><td>value<td>2<td>&ldquo;x&rdquo;<td>4<td>243<td>&ldquo;f&rdquo;<td>&ldquo;o&rdquo;<td>&ldquo;o&rdquo;<td>249<td>&ldquo;y&rdquo;<td>&ldquo;y&rdquo;<td>…<td>&ldquo;y&rdquo;</table></blockquote><p>Null byte padding MUST NOT be inserted in the middle of a <code>varuint</code>-encoded length.<h1 id=f-e-m>Frames, Envelopes and Messages</h1><p><img src=layout.svg alt="Diagram of frames, envelopes, messages, slots and fields" style=width:90%;margin:1em><p><strong>Frames</strong>: To split a stream (for example data read from a TCP socket, HTTP request body, etc) into messages, we <em>frame</em> the data. A frame is simply a length prefix. The length is encoded as <a href=#varuint>varuint</a>, typically as a single byte. Frames are not interleaved. When the length is implied by the container (for example, key-value store value as a whole), using frames is not necessary.<p><strong>Envelopes</strong>: When we may see multiple different kinds of messages (and different versions of how a message may be laid out also count as different kinds), we need something to differentiate the message type. A leading <a href=#varuint>varuint</a> stores that information. In the schema, an envelope is a map of unsigned integers to message versions.<p><strong>Messages</strong>: This is the actual payload transported. Message contents are defined by a <em>versioned</em> <em>schema</em> that both describes the content of the message and selects the exact <em>wire format</em>.<p>Programs using Chitin can use each layer directly, based on their requirements. The layers are independent: a stream of Messages of the same type can be sent with just Frames, without Envelopes.<p>Every Message does know its length, but only after reading its Fields, whereas a Frame knows its length up front. If messages are consumed fully and sequentially, Frames may be unnecessary. Similarly, when consuming data fully, if unknown Messages in an Envelope are a fatal error, sequences of Envelopes do not necessarily need Frames. Recommendation: If the data length is unknown (a stream), always use Frames, but write Chitin encoding/decoding libraries without such assumptions.<h1 id=frame>Frame</h1><p>Sequential frames are encoded as <a href=#length-prefixed-encoding>length-prefixed encoding</a>.<p>Libraries MUST allow applications to constrain maximum frame length.<p>The data type of the length is explicitly not specified as any fixed size integer. Implementations can pick a size based on what is their supported maximum frame length. Requirement to send or receive frames greater than 4GB SHOULD be explicitly stated in any protocol documentation if assumed, and not all implementations will be able to do so. Library implementors SHOULD NOT choose a size smaller than <code>uint32</code> unless working in very constrained environments.<h1 id=envelope>Envelope</h1><p>An Envelope is encoded as<ul><li><code>varuint</code>: message kind<li>Message</ul><p>Kind 0 means skip this envelope silently, and is used for alignment.<p>As with Frames, the data type of kind is explicitly not specified. Implementations may look at the schema for the envelope and choose a suitable integer size for the maximum number present. Implementations MUST gracefully handle input greater than the chosen size.<h1 id=message-wire-v1>Message wire format v1</h1><p>A <em>Message</em> is a sequence of fixed-length <em>Slots</em> followed by a sequence of variable-length <em>Fields</em>.<p>Slots and fields of a message are explicitly described by the versioned message definition in the schema. All slots and fields are required; the closest a field can be to optional is that its length may be 0, e.g. making a string be empty.<p>Libraries typically offer mechanisms to translate system and application types into these types, for things like timestamps. (<strong>TODO schema should be able to talk about more abstract types, e.g. to say &ldquo;this is nanoseconds since unix epoch&rdquo;</strong>)<p>We will use the following short hand notation:<ul><li><code>M</code>: a placeholder for any message type<li><code>S</code>: a placeholder for any slot type<li><code>F</code>: a placeholder for any field type<li><code>T</code>: a placeholder for any type that is valid in that context: <code>S</code> when talking about slots, <code>F</code> when talking about fields</ul><p>Message schema can specify a minimum alignment for the message.<p>Messages with no Envelope or Frame around them are correctly aligned by relying of aligned buffer allocation (see <a href=#alignment>Alignment</a>).<p>Messages in Frames, either with or without Envelopes, are aligned by prefixing 0-length Frames as appropriate. Note that the encoding of the intermediate Envelope affects the amount of padding required.<p>Messages in Envelopes, without Frames, are aligned by prefixing Envelopes with kind 0.<p>(Pragmatically, with and without Frames, the data is zero-prefixed, but a Frame can only contain one Envelope or Message.)<h2 id=slot>Slot</h2><p>A Slot contains one of the following data types:<ul><li><code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code><li><code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code><li><code>float32</code>, <code>float64</code><li><code>byte</code><li>(<strong>TODO convenience support for bit maps, flags</strong>)<li><code>M</code>: messages that do not contain fields<li><code>[n]S</code>: fixed length arrays of any of these types</ul><p>Single-byte fields are encoded as-is.<p>Multi-byte numbers are encoded in big endian, to allow using messages as lexicographical sort keys.<p>Floats are encoded as per IEEE-754.<p>Note that arrays of arrays are supported.<p>Slots are not aligned automatically. Given a sufficient alignment guarantee set on the containing message, you can arrange slots to provide the desired layout. Padding is explicit, and done with fields named <code>_</code>.<h2 id=field>Field</h2><p>Fields can be by their very nature variable length. There are three cases of how the field length is known, which may combine in any order, and are collectively encoded as specified in <a href=#interleaving-fixed-length-items>Interleaving fixed length items</a>.<p>Message schema can specify a minimum alignment for a field.<h3 id=fixed-length-fields>Fixed length fields</h3><ul><li><code>uint8</code><li><code>int8</code><li><code>byte</code><li>(<strong>TODO convenience support for bit maps, flags, combinations</strong>)<li><code>M</code>: messages that do not contain fields<li><code>[n]S</code>: fixed length arrays of fixed-length types</ul><p>These are encoded as in slots. They do not encode a length prefix. They are supported in fields mostly for completeness; they are probably better off put in slots.<h3 id=self-delimited-fields>Self-delimited fields</h3><ul><li><code>uint16</code>, <code>uint32</code>, <code>uint64</code><li><code>int16</code>, <code>int32</code>, <code>int64</code><li><code>float32</code>, <code>float64</code></ul><p>Encoded in a way that does not need a separate length prefix. These are all short enough that having a separate length prefix would be wasteful.<p>Multi-byte integers are encoded as <a href=#varuint><code>varuint</code></a> or <a href=#varsint><code>varsint</code></a>, respectively.<p>Floats are encoded as <a href=#varfloat><code>varfloat</code></a>.<h3 id=length-prefixed-fields>Length-prefixed fields</h3><ul><li><code>M</code>: messages that contain fields<li><code>[]S</code>: variable length arrays of fixed-length types<li><code>string</code></ul><p>These use <a href=#length-prefixed-encoding>length-prefixed encoding</a> as specified earlier.<h3 id=encoding-more-complex-types>Encoding more complex types</h3><p>Arrays of arrays are supported, but inner arrays must be fixed length.<p>Arrays with variable-length items can be stored by storing <em>Framed</em> messages in a <code>[]byte</code>. In that case, constant-time lookup by index is not supported.<p>Maps (aka dictionaries) of fixed-length keys and values can be stored as an array of messages, with the message having slots for key and value. Constant-time lookup by key is not supported, only by index.<p>Maps of variable-length items can be stored similarly using the above method for storing arrays of variable-length items.<h1 id=schema>Schema</h1><p><strong>TODO</strong><p><strong>TODO how do slots &amp; fields refer to messages</strong><h2 id=schema-data-model>Schema Data Model</h2><p><strong>TODO</strong><h2 id=schema-language>Schema Language</h2><p><strong>TODO</strong><h1 id=rationale>Rationale</h1><p><em>This section is non-normative.</em><h2 id=varuint-1>varuint</h2><p>We use <a href=http://www.sqlite.org/src4/doc/trunk/www/varint.wiki>SQLite&rsquo;s Variable-Length Integers</a>, opting to call them <code>varuint</code> inspired by <a href=https://github.com/dchest/varuint>github.com/dchest/varuint</a>, to encode integers in to least possible number of bytes.<p><code>varuint</code> wins over Protocol Buffers&rsquo; zigzag encoding for numbers in the 128-240 range, which is very common for message field lengths.<p><code>varuint</code> numbers sort properly in lexicographic order.<p><code>varuint</code> puts the length of the encoded data in the first byte, a property Protocol Buffers authors have said they would use, except for legacy reasons.<h2 id=interleaved-field-lengths-and-contents>Interleaved field lengths and contents</h2><p>The <a href=#length-prefixed-encoding>length-prefixed encoding</a> interleaves lengths and contents, because it seems like the best trade-off.<p>Other length-first formats have experienced pains from this decision too, e.g. there&rsquo;s been talk of a Protocol Buffers encoding optimization where the outgoing message byte buffer is constructed back-to-front, so the field sizes are more naturally known at the time they need to be encoded.<p>Let&rsquo;s look at the alternatives.<p>If <em>all</em> lengths were up <em>front</em>:<ul><li>Assuming <code>varuint</code> encoding for lengths, we wouldn&rsquo;t know where to start writing the content of the first field until we know how we&rsquo;ll encode all of the lengths. (Fixed-size lengths would mitigate this, but be wasteful in other ways.)<li>We&rsquo;d need to compute sizes for potentially large, potentially on-demand generated contents &ndash; and then remember the contents, for later use.<li>We could not start streaming the first field until after we&rsquo;d computed sizes for all fields.<li>The same mechanism would not serve us for Frames, where future frame lengths may depend on user input etc.</ul><p>If <em>all</em> lengths were at the <em>back</em>:<ul><li>We wouldn&rsquo;t know where to write them until we&rsquo;d know the sizes of all of the fields. This is less of a problem than above, as we could buffer the relatively small field sizes elsewhere.<li>We could not start processing any of the streamed fields until after we&rsquo;d received them all, to see the sizes.<li>The same mechanism would not serve us for Frames, where future frame lengths may depend on user input etc.</ul><p>Field lengths could be <em>implicit</em>:<ul><li>Using something like <a href=https://en.wikipedia.org/wiki/Consistent_Overhead_Byte_Stuffing>COBS</a>, every field could be self-terminating.<li>This means we don&rsquo;t need to know the size of a field before we start writing it. That&rsquo;s nice, but decode having to look at every byte of the field is not.<li>For the purposes of the discussion here, this is pretty much equivalent to interleaving lengths and contents.</ul><p>So, some sort of interleaving seems ideal.<p>Our desire to support alignment guarantees causes wasteful null padding. <a href=#padding-optimization>Padding optimization</a> minimizes that, at the cost of complexity. If that complexity is demonstrated to be a significant barrier, we&rsquo;ll remove the optimization.<h2 id=null-padding-is-not-visible-to-applications>Null padding is not visible to applications</h2><p>0-length Frames and 0-kind Envelopes are never exposed to the application by a library. This is so that it&rsquo;s always safe to<ul><li>insert null padding into Framed connections to avoid idle disconnections<li>choose whether to do <a href=#padding-optimization>padding optimization</a> based on whether the size of the next field has already been computer or not<li>to concatenate two Framed streams, using the padding to guarantee alignments in the second stream</ul><p>And so on. If applications were to see the pure padding entries, their behavior might change, even from just timing differences.</p><div class=footnotes><hr><ol><li id=fn:varfloat>This idea came from &ldquo;Floats are converted to IEEE754, byte reversed, then uvarint encoded.&rdquo; in <a href=https://github.com/sbunce/gosu>https://github.com/sbunce/gosu</a> <a class=footnote-return href=#fnref:varfloat><sup>[return]</sup></a></ol></div></div><div style=flex-grow:1;flex-basis:0;display:flex><div style=flex:1;order:1;flex-grow:0;flex-basis:100px;display:flex><nav class=sidebar style=flex:1><ul><li><a href=/>Introduction<p>and motivation</p></a><li><a href=/spec/v1/>Specification<p>details about the wire format</p></a><li><a href=/code/>Code<p>to actually get things done</p></a></ul></nav></div></div><div style=order:-1;flex-basis:0;flex-grow:1;display:flex;flex-direction:column><img src=/chitin.svg alt style=flex:1;align-self:flex-end;margin:20px;max-height:10em></div>